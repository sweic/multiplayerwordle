{"ast":null,"code":"import { VALIDGUESSES, WORDS } from \"../constants\";\nexport function checkKey(e, historyRef, gameStatusRef, currentRowRef, setHistory, setCurrentRow, setWinner, setRematch, setError, wordle, client, clientID, gameID, user) {\n  if (historyRef.current.length == 6 || gameStatusRef.current) return;\n  console.log(e.keyCode);\n  console.log(e.key);\n\n  if (currentRowRef.current.length == 5) {\n    if (e.keyCode == 13) {\n      console.log(\"entered\");\n      var word = currentRowRef.current;\n      console.log(word);\n\n      if (!VALIDGUESSES.includes(word.join('')) && !WORDS.includes(word.join(''))) {\n        setError(true);\n        setTimeout(() => {\n          setError(false);\n        }, 2000);\n        return;\n      }\n\n      var target = wordle;\n      const final = computeGuess(currentRowRef.current, wordle);\n      setHistory([...historyRef.current, final]);\n      setCurrentRow([]); //    dispatch({type: actionTypes.ACCEPT_RESPONSE, payload: final})\n\n      client.send(JSON.stringify({\n        type: \"update\",\n        payload: {\n          rows: historyRef.current,\n          clientID: clientID,\n          gameID: gameID\n        }\n      })); //    setCurrentRow([])\n\n      if (final.every(value => value.status == \"green\")) {\n        const data = {\n          type: \"winner\",\n          payload: {\n            winner: user,\n            gameID: gameID\n          }\n        };\n        client.send(JSON.stringify(data));\n        setWinner(true);\n        setRematch(true);\n      }\n    } else if (e.keyCode == 8) {\n      const tmp = currentRowRef.current.slice(0, currentRowRef.current.length - 1);\n      setCurrentRow(tmp);\n    }\n  } else if (e.keyCode == 8) {\n    const tmp = currentRowRef.current.slice(0, currentRowRef.current.length - 1);\n    setCurrentRow(tmp);\n  } else if (currentRowRef.current.length < 5) {\n    if (e.keyCode >= 65 && e.keyCode <= 90) {\n      setCurrentRow([...currentRowRef.current, e.key]);\n    }\n  }\n}\nexport function resetKeys(dirtyKeys) {\n  for (var i in dirtyKeys) {\n    for (var j in dirtyKeys[i]) {\n      dirtyKeys[i][j].status = \"none\";\n    }\n  }\n\n  return dirtyKeys;\n}\nexport function colourKeys(initKeysOne, history) {\n  for (var a in history) {\n    for (var c in history[a]) {\n      var flag = false;\n      if (flag) break;else {\n        for (const j in initKeysOne) {\n          for (var b in initKeysOne[j]) {\n            if (history[a][c].key == initKeysOne[j][b].key) {\n              if (initKeysOne[j][b] == \"green\" || \"yellow\" && history[a][c].status == \"none\") {\n                flag = true;\n                break;\n              }\n\n              initKeysOne[j][b].status = history[a][c].status;\n              flag = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return initKeysOne;\n}\n\nfunction computeGuess(guess, wordle) {\n  // for (var i in word) {\n  //     var status = \"gray\"\n  //     if (word[i] == target[i]) {\n  //         status = \"green\"\n  //         target = target.replace(word[i], \" \")\n  //     } else if (target.includes(word[i])) {\n  //         status = \"yellow\"\n  //         target = target.replace(word[i], \" \")\n  //     } \n  //     final.push({key: word[i], status: status});\n  // }\n  var target = wordle.split('');\n  var letters = guess;\n  var final = Array(target.length);\n  var unchecked = Array(target.length).fill(0);\n\n  for (var i in letters) {\n    if (letters[i] == target[i]) {\n      final[i] = {\n        key: letters[i],\n        status: \"green\"\n      };\n      unchecked[i] = 1;\n      target[i] = null;\n      letters[i] = null;\n    }\n  }\n\n  for (var j in letters) {\n    if (letters[j] == null) continue;\n\n    if (target.includes(letters[j])) {\n      final[j] = {\n        key: letters[j],\n        status: \"yellow\"\n      };\n      unchecked[j] = 1;\n      const idx = target.indexOf(letters[j]);\n      target[idx] = null;\n      letters[j] = null;\n    }\n  }\n\n  for (var k in unchecked) {\n    if (unchecked[k] == 0) {\n      final[k] = {\n        keys: letters[k],\n        status: \"none\"\n      };\n    }\n  }\n\n  console.log(final);\n  return final;\n}","map":{"version":3,"sources":["C:/Users/ytdan/OneDrive/Desktop/Computer Science/MERN/wordleio/client/src/functions/handler.js"],"names":["VALIDGUESSES","WORDS","checkKey","e","historyRef","gameStatusRef","currentRowRef","setHistory","setCurrentRow","setWinner","setRematch","setError","wordle","client","clientID","gameID","user","current","length","console","log","keyCode","key","word","includes","join","setTimeout","target","final","computeGuess","send","JSON","stringify","type","payload","rows","every","value","status","data","winner","tmp","slice","resetKeys","dirtyKeys","i","j","colourKeys","initKeysOne","history","a","c","flag","b","guess","split","letters","Array","unchecked","fill","idx","indexOf","k","keys"],"mappings":"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","sourcesContent":["import { VALIDGUESSES, WORDS } from \"../constants\";\r\n\r\nexport function checkKey(e, historyRef, gameStatusRef, currentRowRef, setHistory, setCurrentRow, setWinner, setRematch, setError, wordle, client, clientID, gameID, user) {\r\n    if (historyRef.current.length == 6 || gameStatusRef.current ) return;\r\n    console.log(e.keyCode);\r\n    console.log(e.key);\r\n    \r\n    if (currentRowRef.current.length == 5) {\r\n        \r\n        if (e.keyCode == 13) {\r\n            console.log(\"entered\");\r\n            var word = currentRowRef.current\r\n\r\n            console.log(word);\r\n            if (!VALIDGUESSES.includes(word.join('')) && !WORDS.includes(word.join(''))) {\r\n                setError(true);\r\n                setTimeout(() => {\r\n                    setError(false)\r\n                }, 2000)\r\n                return \r\n            }\r\n       var target = wordle;\r\n       const final = computeGuess(currentRowRef.current, wordle);\r\n       setHistory([...historyRef.current, final])\r\n       setCurrentRow([])\r\n     \r\n    //    dispatch({type: actionTypes.ACCEPT_RESPONSE, payload: final})\r\n       client.send(JSON.stringify({type: \"update\", payload: {rows: historyRef.current, clientID: clientID, gameID: gameID}}));\r\n    //    setCurrentRow([])\r\n       if (final.every((value) => value.status == \"green\")) {\r\n        const data = {\r\n            type: \"winner\",\r\n            payload: {\r\n                winner: user,\r\n                gameID: gameID\r\n                }\r\n        }\r\n        client.send(JSON.stringify(data));\r\n        setWinner(true);\r\n        setRematch(true);\r\n     }\r\n        } \r\n        else if (e.keyCode == 8) {\r\n            const tmp = currentRowRef.current.slice(0, currentRowRef.current.length - 1)\r\n            setCurrentRow(tmp)\r\n        }\r\n    } else if (e.keyCode == 8) {\r\n        const tmp = currentRowRef.current.slice(0, currentRowRef.current.length - 1)\r\n        setCurrentRow(tmp)\r\n    } else if (currentRowRef.current.length < 5) {\r\n        if (e.keyCode >= 65 && e.keyCode <= 90) {\r\n            setCurrentRow([...currentRowRef.current, e.key])\r\n        }\r\n\r\n    }\r\n}\r\n\r\nexport function resetKeys(dirtyKeys) {\r\n    for (var i in dirtyKeys) {\r\n        for (var j in dirtyKeys[i]) {\r\n            dirtyKeys[i][j].status = \"none\";\r\n        }\r\n    }\r\n    return dirtyKeys;\r\n}\r\n\r\nexport function colourKeys(initKeysOne, history) {\r\n    for (var a in history) {\r\n        for (var c in history[a]) {\r\n            var flag = false\r\n            if (flag) break;\r\n            else {\r\n                for (const j in initKeysOne) {\r\n                    for (var b in initKeysOne[j]) {\r\n                        if (history[a][c].key == initKeysOne[j][b].key) {\r\n                            if (initKeysOne[j][b] == \"green\" || \"yellow\" && history[a][c].status == \"none\") {\r\n                                flag = true;\r\n                                break;\r\n                            }\r\n                            initKeysOne[j][b].status = history[a][c].status\r\n                            flag = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                \r\n            }\r\n            \r\n        }\r\n    }\r\n    return initKeysOne\r\n}\r\n\r\nfunction computeGuess(guess, wordle) {\r\n    // for (var i in word) {\r\n    //     var status = \"gray\"\r\n    //     if (word[i] == target[i]) {\r\n    //         status = \"green\"\r\n    //         target = target.replace(word[i], \" \")\r\n    //     } else if (target.includes(word[i])) {\r\n    //         status = \"yellow\"\r\n    //         target = target.replace(word[i], \" \")\r\n    //     } \r\n    //     final.push({key: word[i], status: status});\r\n       \r\n    // }\r\n    var target = wordle.split('');\r\n    var letters = guess\r\n    var final = Array(target.length)\r\n    var unchecked = Array(target.length).fill(0);\r\n    \r\n\r\n\r\n    for (var i in letters) {\r\n        if (letters[i] == target[i]) {\r\n            final[i] = ({key: letters[i], status: \"green\"})\r\n            unchecked[i] = 1\r\n            target[i] = null;\r\n            letters[i] = null;\r\n            \r\n        }\r\n    }\r\n\r\n    for (var j in letters) {\r\n        if (letters[j] == null) continue;\r\n        if (target.includes(letters[j])) {\r\n            final[j] = ({key: letters[j], status: \"yellow\"})\r\n            unchecked[j] = 1;\r\n            const idx = target.indexOf(letters[j]);\r\n            target[idx] = null;\r\n            letters[j] = null;\r\n        }\r\n    }\r\n\r\n    for (var k in unchecked) {\r\n        if (unchecked[k] == 0) {\r\n            final[k] = ({keys: letters[k], status: \"none\"});\r\n        }\r\n    }\r\n    console.log(final);\r\n    return final;\r\n\r\n}"]},"metadata":{},"sourceType":"module"}