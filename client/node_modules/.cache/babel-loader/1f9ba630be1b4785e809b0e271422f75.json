{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { VALIDGUESSES, WORDS } from \"../constants\";\nimport React, { useState } from 'react';\nimport { useStateRef } from \"../hooks\";\nexport const useGameStatus = () => {\n  _s();\n\n  const [gameStatus, gameStatusRef, setGameStatus] = useStateRef(false);\n  const [currentRow, currentRowRef, setCurrentRow] = useStateRef([]);\n  const [history, historyRef, setHistory] = useStateRef([]);\n  const [error, setError] = useState(false);\n  const [winner, setWinner] = useState(null);\n  const [rematch, setRematch] = useState(false);\n\n  const checkKey = (e, wordle, client, clientID, gameID, user) => {\n    if (historyRef.current.length == 6 || gameStatusRef.current) return;\n\n    if (currentRowRef.current.length == 5) {\n      if (e.keyCode == 13) {\n        var word = currentRowRef.current;\n\n        if (!VALIDGUESSES.includes(word.join('')) && !WORDS.includes(word.join(''))) {\n          setError(true);\n          setTimeout(() => {\n            setError(false);\n          }, 2000);\n          return;\n        }\n\n        var target = wordle;\n        const final = computeGuess(currentRowRef.current, wordle);\n        setHistory([...historyRef.current, final]);\n        setCurrentRow([]);\n        client.send(JSON.stringify({\n          type: \"update\",\n          payload: {\n            rows: historyRef.current,\n            clientID: clientID,\n            gameID: gameID\n          }\n        }));\n\n        if (final.every(value => value.status == \"green\")) {\n          const data = {\n            type: \"winner\",\n            payload: {\n              winner: user,\n              gameID: gameID\n            }\n          };\n          client.send(JSON.stringify(data));\n          setWinner(true);\n          setRematch(true);\n          return;\n        }\n\n        if (historyRef.current.length == 6) {\n          const data = {\n            type: \"max\",\n            payload: {\n              gameID: gameID\n            }\n          };\n          client.send(JSON.stringify(data));\n        }\n      } else if (e.keyCode == 8) {\n        const tmp = currentRowRef.current.slice(0, currentRowRef.current.length - 1);\n        setCurrentRow(tmp);\n      }\n    } else if (e.keyCode == 8) {\n      const tmp = currentRowRef.current.slice(0, currentRowRef.current.length - 1);\n      setCurrentRow(tmp);\n    } else if (currentRowRef.current.length < 5) {\n      if (e.keyCode >= 65 && e.keyCode <= 90) {\n        setCurrentRow([...currentRowRef.current, e.key]);\n      }\n    }\n  };\n\n  const resetKeys = dirtyKeys => {\n    for (var i of Object.keys(dirtyKeys)) {\n      dirtyKeys[i].status = \"none\";\n    }\n\n    return dirtyKeys;\n  };\n\n  const colourKeys = initKeysOne => {\n    const idx = history.length - 1;\n\n    for (var i in history[idx]) {\n      const targetKey = history[idx][i].key;\n      if (initKeysOne[targetKey].status == \"green\") continue;\n      if (initKeysOne[targetKey].status == \"yellow\" && history[idx][i].status == \"gray\") continue;\n      initKeysOne[targetKey].status = history[idx][i].status;\n    }\n\n    return initKeysOne;\n  };\n\n  const computeGuess = (guess, wordle) => {\n    var target = wordle.split('');\n    var letters = guess;\n    var final = Array(target.length);\n    var unchecked = Array(target.length).fill(0);\n\n    for (var i in letters) {\n      if (letters[i] == target[i]) {\n        final[i] = {\n          key: letters[i],\n          status: \"green\"\n        };\n        unchecked[i] = 1;\n        target[i] = null;\n        letters[i] = null;\n      }\n    }\n\n    for (var j in letters) {\n      if (letters[j] == null) continue;\n\n      if (target.includes(letters[j])) {\n        final[j] = {\n          key: letters[j],\n          status: \"yellow\"\n        };\n        unchecked[j] = 1;\n        const idx = target.indexOf(letters[j]);\n        target[idx] = null;\n        letters[j] = null;\n      }\n    }\n\n    for (var k in unchecked) {\n      if (unchecked[k] == 0) {\n        final[k] = {\n          key: letters[k],\n          status: \"gray\"\n        };\n      }\n    }\n\n    return final;\n  };\n\n  return {\n    gameStatusRef,\n    setGameStatus,\n    currentRow,\n    currentRowRef,\n    setCurrentRow,\n    history,\n    historyRef,\n    setHistory,\n    error,\n    setError,\n    winner,\n    setWinner,\n    rematch,\n    setRematch,\n    resetKeys,\n    colourKeys,\n    checkKey\n  };\n};\n\n_s(useGameStatus, \"Q0N3W6np4tkd3V/5+MQ6fYM02IA=\", false, function () {\n  return [useStateRef, useStateRef, useStateRef];\n});","map":{"version":3,"sources":["C:/Users/ytdan/OneDrive/Desktop/Computer Science/MERN/wordle-io/client/src/functions/handler.js"],"names":["VALIDGUESSES","WORDS","React","useState","useStateRef","useGameStatus","gameStatus","gameStatusRef","setGameStatus","currentRow","currentRowRef","setCurrentRow","history","historyRef","setHistory","error","setError","winner","setWinner","rematch","setRematch","checkKey","e","wordle","client","clientID","gameID","user","current","length","keyCode","word","includes","join","setTimeout","target","final","computeGuess","send","JSON","stringify","type","payload","rows","every","value","status","data","tmp","slice","key","resetKeys","dirtyKeys","i","Object","keys","colourKeys","initKeysOne","idx","targetKey","guess","split","letters","Array","unchecked","fill","j","indexOf","k"],"mappings":"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","sourcesContent":["import { VALIDGUESSES, WORDS } from \"../constants\";\r\nimport React, {useState} from 'react'\r\nimport { useStateRef } from \"../hooks\";\r\nexport const useGameStatus = () => {\r\n    const [gameStatus, gameStatusRef, setGameStatus] = useStateRef(false);\r\n    const [currentRow, currentRowRef, setCurrentRow] = useStateRef([])\r\n    const [history, historyRef, setHistory] = useStateRef([])\r\n    const [error, setError] = useState(false)\r\n    const [winner, setWinner] = useState(null);\r\n    const [rematch, setRematch] = useState(false);\r\n\r\n    const checkKey = (e, wordle, client, clientID, gameID, user)  => {\r\n        if (historyRef.current.length == 6 || gameStatusRef.current ) return;\r\n    \r\n      \r\n        if (currentRowRef.current.length == 5) {\r\n            \r\n            if (e.keyCode == 13) {\r\n               \r\n                var word = currentRowRef.current\r\n                if (!VALIDGUESSES.includes(word.join('')) && !WORDS.includes(word.join(''))) {\r\n                    setError(true);\r\n                    setTimeout(() => {\r\n                        setError(false)\r\n                    }, 2000)\r\n                    return \r\n                }\r\n           var target = wordle;\r\n           const final = computeGuess(currentRowRef.current, wordle);\r\n           setHistory([...historyRef.current, final])\r\n           setCurrentRow([])\r\n         \r\n           client.send(JSON.stringify({type: \"update\", payload: {rows: historyRef.current, clientID: clientID, gameID: gameID}}));\r\n           if (final.every((value) => value.status == \"green\")) {\r\n            const data = {\r\n                type: \"winner\",\r\n                payload: {\r\n                    winner: user,\r\n                    gameID: gameID\r\n                    }\r\n            }\r\n            client.send(JSON.stringify(data));\r\n            setWinner(true);\r\n            setRematch(true);\r\n            return;\r\n         }\r\n         if (historyRef.current.length == 6) {\r\n             const data = {\r\n                 type:\"max\",\r\n                 payload: {gameID: gameID}\r\n             }\r\n    \r\n             client.send(JSON.stringify(data));\r\n             \r\n         }\r\n            } \r\n            else if (e.keyCode == 8) {\r\n                const tmp = currentRowRef.current.slice(0, currentRowRef.current.length - 1)\r\n                setCurrentRow(tmp)\r\n            }\r\n        } else if (e.keyCode == 8) {\r\n            const tmp = currentRowRef.current.slice(0, currentRowRef.current.length - 1)\r\n            setCurrentRow(tmp)\r\n        } else if (currentRowRef.current.length < 5) {\r\n            if (e.keyCode >= 65 && e.keyCode <= 90) {\r\n                setCurrentRow([...currentRowRef.current, e.key])\r\n            }\r\n    \r\n        }\r\n        \r\n    }\r\n\r\n\r\n    const resetKeys = (dirtyKeys) => {\r\n        for (var i of Object.keys(dirtyKeys)) {\r\n            dirtyKeys[i].status = \"none\";\r\n        }\r\n        return dirtyKeys;\r\n    }\r\n\r\n     \r\n    const colourKeys = (initKeysOne) => {\r\n        const idx = history.length - 1;\r\n        for (var i in history[idx]) {\r\n            const targetKey = history[idx][i].key;\r\n            if (initKeysOne[targetKey].status == \"green\") continue;\r\n            if (initKeysOne[targetKey].status == \"yellow\" && history[idx][i].status == \"gray\") continue;\r\n            initKeysOne[targetKey].status = history[idx][i].status; \r\n        }\r\n        return initKeysOne;\r\n    }\r\n    const computeGuess = (guess, wordle) => {\r\n        var target = wordle.split('');\r\n        var letters = guess\r\n        var final = Array(target.length)\r\n        var unchecked = Array(target.length).fill(0);\r\n    \r\n\r\n\r\n        for (var i in letters) {\r\n            if (letters[i] == target[i]) {\r\n                final[i] = ({key: letters[i], status: \"green\"})\r\n                unchecked[i] = 1\r\n                target[i] = null;\r\n                letters[i] = null;\r\n                \r\n            }\r\n        }\r\n\r\n        for (var j in letters) {\r\n            if (letters[j] == null) continue;\r\n            if (target.includes(letters[j])) {\r\n                final[j] = ({key: letters[j], status: \"yellow\"})\r\n                unchecked[j] = 1;\r\n                const idx = target.indexOf(letters[j]);\r\n                target[idx] = null;\r\n                letters[j] = null;\r\n            }\r\n        }\r\n\r\n        for (var k in unchecked) {\r\n            if (unchecked[k] == 0) {\r\n                final[k] = ({key: letters[k], status: \"gray\"});\r\n            }\r\n        }\r\n    \r\n        return final;\r\n\r\n}\r\n    return {gameStatusRef, setGameStatus, currentRow, currentRowRef, setCurrentRow, history, historyRef, setHistory, error, setError, winner, setWinner, rematch, setRematch, resetKeys, colourKeys, checkKey}\r\n\r\n}\r\n\r\n\r\n"]},"metadata":{},"sourceType":"module"}