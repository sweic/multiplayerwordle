{"ast":null,"code":"import { VALIDGUESSES, WORDS } from \"../constants\";\nexport function checkKey(e, historyRef, gameStatusRef, currentRowRef, setHistory, setCurrentRow, setWinner, setRematch, setError, wordle, client, clientID, gameID, user) {\n  if (historyRef.current.length == 6 || gameStatusRef.current) return;\n\n  if (currentRowRef.current.length == 5) {\n    if (e.keyCode == 13) {\n      var word = currentRowRef.current;\n\n      if (!VALIDGUESSES.includes(word.join('')) && !WORDS.includes(word.join(''))) {\n        setError(true);\n        setTimeout(() => {\n          setError(false);\n        }, 2000);\n        return;\n      }\n\n      var target = wordle;\n      const final = computeGuess(currentRowRef.current, wordle);\n      setHistory([...historyRef.current, final]);\n      setCurrentRow([]);\n      client.send(JSON.stringify({\n        type: \"update\",\n        payload: {\n          rows: historyRef.current,\n          clientID: clientID,\n          gameID: gameID\n        }\n      }));\n\n      if (final.every(value => value.status == \"green\")) {\n        const data = {\n          type: \"winner\",\n          payload: {\n            winner: user,\n            gameID: gameID\n          }\n        };\n        client.send(JSON.stringify(data));\n        setWinner(true);\n        setRematch(true);\n        return;\n      }\n\n      if (historyRef.current.length == 6) {\n        const data = {\n          type: \"max\",\n          payload: {\n            gameID: gameID\n          }\n        };\n        client.send(JSON.stringify(data));\n      }\n    } else if (e.keyCode == 8) {\n      const tmp = currentRowRef.current.slice(0, currentRowRef.current.length - 1);\n      setCurrentRow(tmp);\n    }\n  } else if (e.keyCode == 8) {\n    const tmp = currentRowRef.current.slice(0, currentRowRef.current.length - 1);\n    setCurrentRow(tmp);\n  } else if (currentRowRef.current.length < 5) {\n    if (e.keyCode >= 65 && e.keyCode <= 90) {\n      setCurrentRow([...currentRowRef.current, e.key]);\n    }\n  }\n}\nexport function resetKeys(dirtyKeys) {\n  // for (var i in dirtyKeys) {\n  //     for (var j in dirtyKeys[i]) {\n  //         dirtyKeys[i][j].status = \"none\";\n  //     }\n  // }\n  // return dirtyKeys;\n  for (var i of Object.keys(dirtyKeys)) {\n    dirtyKeys[i].status = \"none\";\n  }\n\n  return dirtyKeys;\n}\nexport function colourKeys(initKeysOne, history) {\n  // for (var a in history) {\n  //     for (var c in history[a]) {\n  //         var flag = false\n  //         if (flag) break;\n  //         else {\n  //             for (const j in initKeysOne) {\n  //                 for (var b in initKeysOne[j]) {\n  //                     if (history[a][c].key == initKeysOne[j][b].key) {\n  //                         if (initKeysOne[j][b] == \"green\" || \"yellow\" && history[a][c].status == \"none\") {\n  //                             flag = true;\n  //                             break;\n  //                         }\n  //                         initKeysOne[j][b].status = history[a][c].status\n  //                         flag = true;\n  //                         break;\n  //                     }\n  //                 }\n  //             }\n  //         }\n  //     }\n  // }\n  // return initKeysOne\n  const idx = history.length - 1;\n\n  for (var i in history[idx]) {\n    const targetKey = history[idx][i].key;\n    if (initKeysOne[targetKey].status == \"green\") continue;\n    if (initKeysOne[targetKey].status == \"yellow\" && history[idx][i].status == \"gray\") continue;\n    initKeysOne[targetKey].status = history[idx][i].status;\n  }\n\n  return initKeysOne;\n}\n\nfunction computeGuess(guess, wordle) {\n  // for (var i in word) {\n  //     var status = \"gray\"\n  //     if (word[i] == target[i]) {\n  //         status = \"green\"\n  //         target = target.replace(word[i], \" \")\n  //     } else if (target.includes(word[i])) {\n  //         status = \"yellow\"\n  //         target = target.replace(word[i], \" \")\n  //     } \n  //     final.push({key: word[i], status: status});\n  // }\n  var target = wordle.split('');\n  var letters = guess;\n  var final = Array(target.length);\n  var unchecked = Array(target.length).fill(0);\n\n  for (var i in letters) {\n    if (letters[i] == target[i]) {\n      final[i] = {\n        key: letters[i],\n        status: \"green\"\n      };\n      unchecked[i] = 1;\n      target[i] = null;\n      letters[i] = null;\n    }\n  }\n\n  for (var j in letters) {\n    if (letters[j] == null) continue;\n\n    if (target.includes(letters[j])) {\n      final[j] = {\n        key: letters[j],\n        status: \"yellow\"\n      };\n      unchecked[j] = 1;\n      const idx = target.indexOf(letters[j]);\n      target[idx] = null;\n      letters[j] = null;\n    }\n  }\n\n  for (var k in unchecked) {\n    if (unchecked[k] == 0) {\n      final[k] = {\n        key: letters[k],\n        status: \"gray\"\n      };\n    }\n  }\n\n  return final;\n}","map":{"version":3,"sources":["C:/Users/ytdan/OneDrive/Desktop/Computer Science/MERN/wordleio/client/src/functions/handler.js"],"names":["VALIDGUESSES","WORDS","checkKey","e","historyRef","gameStatusRef","currentRowRef","setHistory","setCurrentRow","setWinner","setRematch","setError","wordle","client","clientID","gameID","user","current","length","keyCode","word","includes","join","setTimeout","target","final","computeGuess","send","JSON","stringify","type","payload","rows","every","value","status","data","winner","tmp","slice","key","resetKeys","dirtyKeys","i","Object","keys","colourKeys","initKeysOne","history","idx","targetKey","guess","split","letters","Array","unchecked","fill","j","indexOf","k"],"mappings":"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","sourcesContent":["import { VALIDGUESSES, WORDS } from \"../constants\";\r\n\r\nexport function checkKey(e, historyRef, gameStatusRef, currentRowRef, setHistory, setCurrentRow, setWinner, setRematch, setError, wordle, client, clientID, gameID, user) {\r\n    if (historyRef.current.length == 6 || gameStatusRef.current ) return;\r\n\r\n  \r\n    if (currentRowRef.current.length == 5) {\r\n        \r\n        if (e.keyCode == 13) {\r\n           \r\n            var word = currentRowRef.current\r\n            if (!VALIDGUESSES.includes(word.join('')) && !WORDS.includes(word.join(''))) {\r\n                setError(true);\r\n                setTimeout(() => {\r\n                    setError(false)\r\n                }, 2000)\r\n                return \r\n            }\r\n       var target = wordle;\r\n       const final = computeGuess(currentRowRef.current, wordle);\r\n       setHistory([...historyRef.current, final])\r\n       setCurrentRow([])\r\n     \r\n       client.send(JSON.stringify({type: \"update\", payload: {rows: historyRef.current, clientID: clientID, gameID: gameID}}));\r\n       if (final.every((value) => value.status == \"green\")) {\r\n        const data = {\r\n            type: \"winner\",\r\n            payload: {\r\n                winner: user,\r\n                gameID: gameID\r\n                }\r\n        }\r\n        client.send(JSON.stringify(data));\r\n        setWinner(true);\r\n        setRematch(true);\r\n        return;\r\n     }\r\n     if (historyRef.current.length == 6) {\r\n         const data = {\r\n             type:\"max\",\r\n             payload: {gameID: gameID}\r\n         }\r\n\r\n         client.send(JSON.stringify(data));\r\n         \r\n     }\r\n        } \r\n        else if (e.keyCode == 8) {\r\n            const tmp = currentRowRef.current.slice(0, currentRowRef.current.length - 1)\r\n            setCurrentRow(tmp)\r\n        }\r\n    } else if (e.keyCode == 8) {\r\n        const tmp = currentRowRef.current.slice(0, currentRowRef.current.length - 1)\r\n        setCurrentRow(tmp)\r\n    } else if (currentRowRef.current.length < 5) {\r\n        if (e.keyCode >= 65 && e.keyCode <= 90) {\r\n            setCurrentRow([...currentRowRef.current, e.key])\r\n        }\r\n\r\n    }\r\n    \r\n}\r\n\r\nexport function resetKeys(dirtyKeys) {\r\n    // for (var i in dirtyKeys) {\r\n    //     for (var j in dirtyKeys[i]) {\r\n    //         dirtyKeys[i][j].status = \"none\";\r\n    //     }\r\n    // }\r\n    // return dirtyKeys;\r\n    for (var i of Object.keys(dirtyKeys)) {\r\n        dirtyKeys[i].status = \"none\";\r\n    }\r\n    return dirtyKeys;\r\n}\r\n\r\nexport function colourKeys(initKeysOne, history) {\r\n    // for (var a in history) {\r\n    //     for (var c in history[a]) {\r\n    //         var flag = false\r\n    //         if (flag) break;\r\n    //         else {\r\n    //             for (const j in initKeysOne) {\r\n    //                 for (var b in initKeysOne[j]) {\r\n    //                     if (history[a][c].key == initKeysOne[j][b].key) {\r\n    //                         if (initKeysOne[j][b] == \"green\" || \"yellow\" && history[a][c].status == \"none\") {\r\n    //                             flag = true;\r\n    //                             break;\r\n    //                         }\r\n                           \r\n    //                         initKeysOne[j][b].status = history[a][c].status\r\n    //                         flag = true;\r\n    //                         break;\r\n    //                     }\r\n    //                 }\r\n    //             }\r\n                \r\n    //         }\r\n            \r\n    //     }\r\n    // }\r\n    // return initKeysOne\r\n    const idx = history.length - 1;\r\n    for (var i in history[idx]) {\r\n        const targetKey = history[idx][i].key;\r\n        if (initKeysOne[targetKey].status == \"green\") continue;\r\n        if (initKeysOne[targetKey].status == \"yellow\" && history[idx][i].status == \"gray\") continue;\r\n        initKeysOne[targetKey].status = history[idx][i].status; \r\n    }\r\n    return initKeysOne;\r\n}\r\n\r\nfunction computeGuess(guess, wordle) {\r\n    // for (var i in word) {\r\n    //     var status = \"gray\"\r\n    //     if (word[i] == target[i]) {\r\n    //         status = \"green\"\r\n    //         target = target.replace(word[i], \" \")\r\n    //     } else if (target.includes(word[i])) {\r\n    //         status = \"yellow\"\r\n    //         target = target.replace(word[i], \" \")\r\n    //     } \r\n    //     final.push({key: word[i], status: status});\r\n       \r\n    // }\r\n    var target = wordle.split('');\r\n    var letters = guess\r\n    var final = Array(target.length)\r\n    var unchecked = Array(target.length).fill(0);\r\n    \r\n\r\n\r\n    for (var i in letters) {\r\n        if (letters[i] == target[i]) {\r\n            final[i] = ({key: letters[i], status: \"green\"})\r\n            unchecked[i] = 1\r\n            target[i] = null;\r\n            letters[i] = null;\r\n            \r\n        }\r\n    }\r\n\r\n    for (var j in letters) {\r\n        if (letters[j] == null) continue;\r\n        if (target.includes(letters[j])) {\r\n            final[j] = ({key: letters[j], status: \"yellow\"})\r\n            unchecked[j] = 1;\r\n            const idx = target.indexOf(letters[j]);\r\n            target[idx] = null;\r\n            letters[j] = null;\r\n        }\r\n    }\r\n\r\n    for (var k in unchecked) {\r\n        if (unchecked[k] == 0) {\r\n            final[k] = ({key: letters[k], status: \"gray\"});\r\n        }\r\n    }\r\n \r\n    return final;\r\n\r\n}"]},"metadata":{},"sourceType":"module"}